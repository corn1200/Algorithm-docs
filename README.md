# Algorithm-docs

# 목차
* [1. 정렬](#1-정렬)

# 1. 정렬
데이터를 정렬해야 하는 이유는 탐색을 위해서이다.  
탐색할 대상 데이터가 정렬되어 있지 않다면 순차 탐색 이외에 다른 알고리즘을 사용할 수 없지만 데이터가 정렬되어 있다면 이진 탐색이라는 강력한 알고리즘을 사용할 수 있다. (알고리즘 문제 등을 풀 때 O(n log n) 보다 빠른 방법은 도저히 없을 것 같다고 판단되는 문제인 경우 일단 정렬하는 걸 가정하고 생각해봐도 무방하다.)   
삽입과 삭제가 자주 되는 자료의 경우 정렬에 더 많은 시간이 들어가므로 순차 탐색을 하는 경우도 있지만(이런 경우는 해시 탐색을 사용하기도 한다.) 대부분의 경우 삽입/삭제보다는 데이터를 조회하는 것이 압도적으로 많고 조회에 필요한 것이 바로 검색이다.

이미 정렬된 데이터의 특징은 어떤 값을 임의로 집었을 때 해당 값을 집은 위치의 오른쪽에는 무조건 그것보다 크거나 같은 값이 있고, 그 위치의 왼쪽에는 무조건 그것보다 작거나 같은 값이 있다는 것이다.   
따라서 컴퓨터가 어떤 값을 딱 집었을 때 찾고자 하는 값보다 집어올린 값이 작다면 그 위치보다 왼쪽은 볼 필요가 없이 그보다 오른쪽만 보면 된다.  
컴퓨터가 어떤 값을 집어올리는 위치가 후보군의 가운데인 탐색 알고리즘이 이진 탐색 알고리즘이다.  
이진 탐색 알고리즘은 최악의 경우라도 log n의 성능을 보이는데 예를 들어 43억 개의 정렬된 자료가 들어있는 데이터에서 어떤 값을 찾아야 할 때 최악의 비교 횟수(찾는 값이 없는 경우)는 겨우 32회에 불과하다.   
33회 비교시에는 약 86억 개의 자료를 탐색할 수 있다.   
더 발전한 알고리즘인 비례탐색 알고리즘(찾는 값이 후보군의 최소값과 최대값 사이의 몇 % 위치에 있는지 계산)은 더 적은 횟수의 비교로 원하는 값을 찾아낼 수 있다.   
컴퓨터에서 정렬을 수행하는 이유 중 가장 큰 이유가 바로 이 이진 탐색이 가능한 데이터를 만들기 위해서이다. (정렬을 필요로 하지 않는 해시 탐색이라는 O(1) 시간복잡도의 알고리즘도 있지만 탐색 항목을 따로 작성해야 한다.)

보통 컴퓨터 분야에서 연구되는 문제들의 경우 사람들이 푸는 방식을 흉내내는 경우가 많은데, 정렬 문제 역시 사람들이 푸는 방식을 흉내낸 형태이다.   
주어진 데이터들이 있으면 값들을 서로 비교하여 순서에 맞게 자리를 바꿔주는 형태로 정렬을 하는데 이를 "비교정렬"이라고 부른다.  

이론과 달리 실제로 알고리즘을 구현하고 실행해 보면 의외로 결과가 다르게 나오는 경우가 종종 있다.  
주로 하드웨어 입출력이 관여해서 그 부분에 걸리는 시간이 정렬 알고리즘마다 과하게 달라서 더 느려야 하는 알고리즘이 더 빠르다던가, 아니면 정렬된 자료들을 대상으로 퀵소트 VS 다른 정렬 알고리즘에서 자주 관찰되는 현상 중 하나로 이론상 정렬된 자료에서는 퀵소트가 더 느려야 하지만 비교하는 기준점이 하나로 고정되어서 그 기준점이 많은 비교를 행하는 퀵소트 특성상 레지스터에 비교하는 기준점 원소를 올려놓고 신속하게 메모리에서 다음 비교할 원소를(메모리에서 연속된) 예측하여 가져오는 경우, 이 과정이 다른 정렬 알고리즘의 메모리에서 레지스터로 올리는 과정에 걸리는 시간이 생략되어 오히려 더 빠른 경우를 볼 수 있다.

실제 응용에서는 상황에 따라 두 가지 이상의 정렬 방법을 사용하는 경우가 많다.  
예를 들면, 정렬 대상이 특정 크기 이하로 단편화될 때까지는 퀵정렬을 쓰다가, 그 특정 크기 이하가 됐을 때에는 작은 규모에서 강점을 보이는 삽입정렬을 쓴다거나, 혹은 특정 횟수 이상 재귀호출이 발생하면 O(n log n)이 보장되는 힙정렬을 쓴다.

# 4.1. O(n^2)
대개 계산 시간이 정렬한 자료의 수의 제곱에 비례해서 늘어난다.   
즉, 1만 개를 1초에 정렬하면 10만 개를 정렬하는 데에는 100초 정도가 필요하다.

# 4.1.1. 버블 정렬
![버블 정렬](/img/bubble_sort0.gif)

버블 정렬을 실행했을 때 나오는 그림.

1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, ..., n-1번째와 n번째를 정렬한 뒤 다시 처음으로 돌아가 이번에는 n-2번째와 n-1번째까지, ...해서 최대 n(n - 1) / 2 번 정렬한다. (이것은 최악의 경우이다. 최선의 경우(이미 정렬된 경우)는 0번)   
한 번 들 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여 거품정렬이다.

거의 모든 상황에서 최악의 성능을 보여준다.  
단, 이미 정렬된 자료에서는 1번만 들면 되기 때문에 최선의 성능을 보여준다.   
이미 정렬된 자료를 정렬하는 이유는 정렬 알고리즘은 자료가 정렬되어 있는지 아닌지는 모르고 작동하기 때문에 의미가 있다.  
가장 손쉽게 구현하여 사용할 수 있지만, 만들기가 쉽고 직관적일 뿐이지 알고리즘적 관점에서 보면 대단히 비효율적인 정렬 방식이다.  
다른 몇 가지 정렬 방식과 비교해도 효율이 극히 안 좋다.

## 구현
```c#
public static void BubbleSort(int[] arr)
{
  int i, j, temp;
  int len = arr.Length;

  for (i = 0; i < len - 1; i++)
  {
    for (j = 0; j < len - i - 1; j++)
    {
      if (arr[j] > arr[j + 1])
      {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
```
버블 정렬을 실행하는 함수를 작성한다.   
파라미터로 정렬할 배열을 전달 받는다.  
차례대로 첫번째 요소부터 마지막 요소까지 비교하면서 현재 요소보다 다음 요소가 작을 경우 위치를 바꾼다.  
한번 비교를 마치면 가장 큰 값이 마지막에 위치하게 된다.   
마지막 요소는 또 비교할 필요가 없기 때문에 비교하는 범위를 줄여서 다시 차례대로 비교하고 위치를 바꾼다.

[파일](/sample_code/AVLTree.cs)
<details>
<summary>C# 예제 코드</summary>

```c#
using System;
using System.Collections;

public class BubbleSortClass
{
  // 버블 정렬 함수
  public static void BubbleSort(int[] arr)
  {
    // 정렬 횟수, 정렬 범위, 데이터 임시 저장 변수
    int i, j, temp;
    // n 크기 선언
    int len = arr.Length;

    // n번 반복
    for (i = 0; i < len - 1; i++)
    {
      // n번 반복할 때마다 반복 범위 줄여나감
      for (j = 0; j < len - i - 1; j++)
      {
        // 현재 원소가 다음 원소보다 클 경우 실행
        if (arr[j] > arr[j + 1])
        {
          // 현재 원소와 다음 원소 위치 변경
          temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
        }
      }
    }
  }
}
```
</details>

# 1.1.2. 칵테일 정렬
![칵테일 정렬](/img/cocktail0.gif)
칵테일 정렬의 과정을 나타낸 그림.

셰이커 정렬(shaker sort)라고도 한다.  
홀수 번째 돌 때는 앞부터, 짝수 번째는 뒤부터 훑는 정렬 방식이다.  
마지막과 처음이 번갈아가며 정렬된다.  

